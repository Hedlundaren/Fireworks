<!doctype html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Blow shit up</title>
	<style>
		body{
			margin: 0px;
			padding: 0px;
			overflow: hidden;
		}
		#container {
			background: #000;
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body>

	<div id="container">


	</div>

</body>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
<script src="js/Three.js"></script>

<script type="text/javascript">
	
	// @see http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	window.requestAnimFrame = (function(){
		return  window.requestAnimationFrame       || 
		window.webkitRequestAnimationFrame || 
		window.mozRequestAnimationFrame    || 
		window.oRequestAnimationFrame      || 
		window.msRequestAnimationFrame     || 
		function(/* function */ callback, /* DOMElement */ element){
			window.setTimeout(callback, 1000 / 60);
		};
	})();
	// set the scene size
	var WIDTH = window.innerWidth,
	HEIGHT = window.innerHeight;
	
	// set some camera attributes
	var VIEW_ANGLE = 90,
	ASPECT = WIDTH / HEIGHT,
	NEAR = 0.1,
	FAR = 10000;

	var particleSystem;
	var particle;
	var particleCount = 40;
	var is_explosion = false;

	particles = new THREE.Geometry(),
	pMaterial = new THREE.ParticleBasicMaterial({
		color: 0xFFFFFF,
		size: 10,
		map: THREE.ImageUtils.loadTexture(
			"images/particle.png"
			),
		blending: THREE.AdditiveBlending,
		transparent: true,
		opacity: 0.5
	});

	for(var p = 0; p < particleCount; p++) {

		particle = new THREE.Vertex(
			new THREE.Vector3(0, 0, 0)
			);

		particle.velocity = new THREE.Vector3(0,0,0);
		particles.vertices.push(particle);
	}

	// get the DOM element to attach to
	// - assume we've got jQuery to hand
	var $container = $('#container');
	
	// create a WebGL renderer, camera
	// and a scene
	var renderer = new THREE.WebGLRenderer();
	var camera = new THREE.Camera(  VIEW_ANGLE,
		ASPECT,
		NEAR,
		FAR  );
	var scene = new THREE.Scene();
	
	camera.position.z = 300;
	renderer.setClearColor(new THREE.Color(0, 1));
	renderer.setSize(WIDTH, HEIGHT);
	$container.append(renderer.domElement);
	
	spawnParticles();

	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	window.addEventListener( 'resize', onWindowResize, false );


	function onDocumentMouseDown( event ) {

		mouseX = (event.clientX);
		mouseY = (event.clientY);
		console.log(mouseX);
		initExplosion();
	}

	function onWindowResize( e ) {
		WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}


	
	// animation loop
	function update() {
		
		if(is_explosion){
			pCount = particleCount;
			while(pCount--){
				particle = particles.vertices[pCount];
				particle.velocity.y -= Math.random() * .01;

				particle.position.addSelf(
				particle.velocity);

			}
		}
		


		//particleSystem.geometry.__dirtyVertices = true;
		renderer.render(scene, camera);

		requestAnimFrame(update);
	}

	function spawnParticles(){

		var particleSystem = new THREE.ParticleSystem(
			particles,
			pMaterial);

		particleSystem.sortParticles = true;
		scene.addChild(particleSystem);
	}

	function initExplosion(){

		is_explosion = true;
		xPos = (Math.random() - 0.5)*200;
		yPos = (Math.random() - 0.5)*200;

		for(var p = 0; p < particleCount; p++) {
			particle = particles.vertices[p];

			particle.position.x = xPos;
			particle.position.y = yPos;
			particle.position.z = 0;

			particle.velocity = new THREE.Vector3(
			Math.random() - 0.5,
			Math.random() - 0.5,
			Math.random() - 0.5);
		}	
	}


requestAnimFrame(update);
</script>
</html>